#BlueJ class context
comment0.params=
comment0.target=MyCITS2200Project()
comment0.text=Initialise\ the\ project
comment1.params=V\ E
comment1.target=void\ testProject(int,\ int)
comment1.text=\r\n\ Initialise\ a\ random\ graph\ for\ testing\r\n\ \r\n\ @param\ V\ The\ number\ of\ verticies\ (pages)\ in\ the\ grapph\r\n\ @param\ E\ the\ number\ of\ edges\ (links)\ in\ the\ graph\r\n
comment10.params=
comment10.target=java.lang.String[]\ Dijkstra_getCenters()
comment10.text=\ Method\ to\ repeatedly\ call\ Dijkstra's\ Single\ Source\ Algorithm\ for\ every\ page\ to\ solve\ the\ all\ pairs\ shortest\ distance\ problem\ -\ then\ uses\ this\ data\ to\ find\ the\ jordan\ centers\ of\ the\ graph.\r\n\ Solves\ Problem\ 4.\r\n\ @return\ The\ page\ urls\ of\ the\ graph\ centers.\r\n
comment11.params=from
comment11.target=java.util.HashMap\ Dijkstra_SingleSource(int)
comment11.text=\r\n\ \ Runs\ Dijkstra's\ algorithm\ on\ a\ directed,\ unweighted\ graph\ to\ find\ the\ distances\ to\ all\ wiki\ pages\ from\ \r\n\ \ the\ specified\ source\ wiki\ page\ to\ solve\ the\ single\ source\ shortest\ path\ problem\r\n\ \ Solves\ (in\ part)\ Problem\ 4.\r\n\ \ @param\ from\ the\ originating\ wiki\ page\r\n\ \ @return\ a\ map\ listing\ the\ distance\ to\ each\ vertex\ in\ the\ single\ source\ shortest\ path\ problem,\ or\ -1\ if\ the\ vertex\ is\ not\ reachable\ from\ the\ source.\r\n
comment12.params=
comment12.target=java.lang.String[]\ FloydWarshall_getCenters()
comment12.text=\r\n\ Runs\ the\ Floyd-Warshall\ algorithm\ to\ find\ the\ all\ paths\ shortest\ problem\ and\ uses\ this\ data\ to\ then\ find\ the\ graph\ centers\r\n\ Solves\ problem\ 4\r\n\ @return\ The\ page\ urls\ of\ the\ graph\ centers.\r\n
comment2.params=urlFrom\ urlTo
comment2.target=void\ addEdge(java.lang.String,\ java.lang.String)
comment2.text=\r\n\ Adds\ an\ edge\ to\ the\ Wikipedia\ page\ graph.\ If\ the\ pages\ do\ not\r\n\ already\ exist\ in\ the\ graph,\ they\ will\ be\ added\ to\ the\ graph.\r\n\ \r\n\ @param\ urlFrom\ the\ URL\ which\ has\ a\ link\ to\ urlTo.\r\n\ @param\ urlTo\ the\ URL\ which\ urlFrom\ has\ a\ link\ to.\r\n
comment3.params=
comment3.target=void\ printGraph()
comment3.text=\r\n\ Prints\ the\ wikipedia\ page\ graph\ to\ the\ console\ log.\r\n
comment4.params=urlFrom\ urlTo
comment4.target=int\ getShortestPath(java.lang.String,\ java.lang.String)
comment4.text=\r\n\ Finds\ the\ shoretst\ path\ in\ number\ of\ links\ between\ two\ pages.\r\n\ \r\n\ @param\ urlFrom\ the\ URL\ where\ the\ path\ should\ start.\r\n\ @param\ urlTo\ the\ URL\ where\ the\ path\ should\ end.\r\n\ @return\ the\ length\ of\ the\ shortest\ path\ in\ number\ of\ links\ followed.\ -1\ if\ no\ path.\r\n
comment5.params=
comment5.target=java.lang.String[]\ getCenters()
comment5.text=\r\n\ Finds\ all\ the\ centers\ of\ the\ page\ graph.\r\n\ \r\n\ @return\ a\ string\ array\ containing\ all\ the\ URL\ strings\ that\ correspond\ to\ pages\ that\ are\ centers.\r\n
comment6.params=
comment6.target=java.lang.String[][]\ getStronglyConnectedComponents()
comment6.text=\r\n\ Finds\ all\ the\ strongly\ connected\ components\ of\ the\ page\ graph.\r\n\ Every\ strongly\ connected\ component\ can\ be\ represented\ as\ an\ array\ \r\n\ containing\ the\ page\ URLs\ in\ the\ component.\ The\ return\ value\ is\ thus\ an\ array\r\n\ of\ strongly\ connected\ components.\ The\ order\ of\ elements\ in\ these\ arrays\r\n\ does\ not\ matter.\ Any\ output\ that\ contains\ all\ the\ strongly\ connected\r\n\ components\ is\ considered\ correct.\r\n\ \r\n\ @return\ an\ array\ containing\ every\ strongly\ connected\ component.\r\n
comment7.params=
comment7.target=java.lang.String[]\ getHamiltonianPath()
comment7.text=\r\n\ Finds\ a\ Hamiltonian\ path\ in\ the\ page\ graph.\ There\ may\ be\ many\r\n\ possible\ Hamiltonian\ paths.\ Any\ of\ these\ paths\ is\ a\ correct\ output.\r\n\ This\ method\ should\ never\ be\ called\ on\ a\ graph\ with\ more\ than\ 20\r\n\ vertices.\ If\ there\ is\ no\ Hamiltonian\ path,\ this\ method\ will\r\n\ return\ an\ empty\ array.\ The\ output\ array\ should\ contain\ the\ URLs\ of\ pages\r\n\ in\ a\ Hamiltonian\ path.\ The\ order\ matters,\ as\ the\ elements\ of\ the\r\n\ array\ represent\ this\ path\ in\ sequence.\ So\ the\ element\ [0]\ is\ the\ start\r\n\ of\ the\ path,\ and\ [1]\ is\ the\ next\ page,\ and\ so\ on.\r\n\ \r\n\ @return\ a\ Hamiltonian\ path\ of\ the\ page\ graph.\r\n
comment8.params=urlFrom\ urlTo
comment8.target=int\ Dijkstra_SinglePair(java.lang.String,\ java.lang.String)
comment8.text=\r\n\ \ Runs\ Dijkstra's\ algorithm\ on\ a\ directed,\ unweighted\ graph\ to\ find\ the\ shortest\ distance\ from\ the\ source\ wiki\ pages\ to\ the\ specified\ source\ wiki\ page\ to\ solve\ the\ "single\ pair"\ shortest\ path\ problem\r\n\ \ Solves\ Problem\ 1.\r\n\ \ @param\ urlFrom\ the\ originating\ wiki\ page\r\n\ \ @param\ urlTo\ the\ destination\ wiki\ page\r\n\ \ @return\ an\ integer\ value\ of\ the\ shortest\ number\ of\ edges\ from\ the\ source\ wikipage\ to\ the\ specified\ wikipage.\r\n
comment9.params=
comment9.target=java.lang.String[]\ BHK_HamiltonPath()
comment9.text=\ \r\n\ Runs\ a\ variant\ of\ the\ Bellman/Held-Karp\ Subset\ Dynamic\ Programming\ algorithm\ to\ find\ the\ hamiltonian\ path\ that\ \r\n\ goes\ through\ every\ wiki\ page\ without\ visiting\ one\ page\ more\ than\ once.\r\n\ Solves\ in\ Problem\ 2.\r\n\ @return\ a\ string\ array\ representing\ the\ verticies\ travelled\ in\ the\ order\ of\ the\ hamiltonian\ path\r\n\ @exception\ if\ Graph\ is\ null\r\n
numComments=13
