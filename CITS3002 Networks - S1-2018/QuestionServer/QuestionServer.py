"""
    Simple socket server using threads
    Based on: https://www.binarytides.com/python-socket-server-code-example/
"""

import json
import os
import random
import socket
import ssl
import sys
import thread

class _Set:
    """ Class for default values """

    HOST = ''
    QPORT = 48009
    BUF_SIZE = 4096
    SEP = '!_!'
    EOM = "#^"
    KEY_LOC = "store"+os.sep+"key.pem"
    PWD_DATA = 'store'+os.sep+'passwords.json'
    MCQ_DATA = 'store'+os.sep+'mcq.json'
    PROG_DATA = 'store'+os.sep+'prog.json'

class _AuthManager:
    """ Class to authenticate sessions """

    def __init__(self):
        self.load_userpass(_Set.PWD_DATA)

    def load_userpass(self, pwd_loc):
        with open(pwd_loc, 'r') as f:
            data = f.read()

        self.user_pass = json.loads(data)       # Dictionary to auth user/pass

    def authenticate(self, user, password):
        if self.user_pass[user] == password:
            return True
        else:
            return False

class _QuestionHandler:
    """ Class to process question databases """

    def __init__(self):
        self.load_databases(_Set.MCQ_DATA, _Set.PROG_DATA)

    def load_databases(self, mcq_loc, prog_loc):
        """ Load mcq and programming question databases"""
        with open(mcq_loc, 'r') as f:
           data = f.read()

        self.mcq = json.loads(data)             # List of String lists (Q, a, b, c, d, ans)

        with open(prog_loc, 'r') as f:
           data = f.read()

        self.prog = json.loads(data)            # List of String lists (Q, ans)

    def generate_quiz(self, q_count):
        """ Select a number of  questions randomly from mcq and programming databases to create a quiz """
        questions = random.sample(self.mcq, q_count-1)
        prog = random.choice(self.prog)
        questions.append(random.choice(self.prog))

        return questions

class _Session:
    """ Class to hold session data """

    def __init__(self, qhandler, session, q_count):
        self.__qhandler = qhandler
        self.id = session
        self.__generate_questions(q_count)

    def __generate_questions(self, q_count):
        """ Populate questions list data using quiz generated by qhandler """
        self.__questions = self.__qhandler.generate_quiz(q_count)

    def _get_question(self, q_num):
        """ Return question fields based on q_num"""
        if q_num < len(self.__questions):
            return self.__questions[q_num][:-1]

    def _get_answer(self, q_num):
        """ Return answer based on q_num"""
        if q_num < len(self.__questions):
            return self.__questions[q_num][-1]

class _QuestionServer:
    """ QuestionServer class """
    
    def __init__(self, host, qport, tls):
        self.host = host
        self.qport = qport
        self.tls = tls
        self.__session_list = []
        self.__qhandler = _QuestionHandler()
        self.__auth = _AuthManager()

    def __start_listen(self):
        s_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print('Socket created')
        s_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
         
        #Bind socket to local host and port
        try:
            s_socket.bind((self.host, self.qport))
        except socket.error as excp:
            print('Err: Bind failed - '+excp[1])
            print('Run > sudo kill $(sudo lsof -t -i:'+str(qport)+')')
            sys.exit()

        #Start listening on socket
        s_socket.listen(10)
        print('QuestionServer: Waiting for connections...')

        return s_socket
     
    def __clientthread(self, soc):
        """ Function for handling connections. This will be used to create threads """
        soc.send('Connected to TestingServer!\n')   # Sending message to connected client
         
        while True:        # Infinite loop so that function doesn't terminate and thread doesn't end.
            # Receive from client

            try:
                data = soc.recv(_Set.BUF_SIZE)

                if not data: 
                    break
                reply = self.__process_data(data)
                if reply != 'cont':
                    soc.sendall(reply)

            except socket.error as excp:
                print('Err: '+str(excp[0])+' Message '+excp[1])
                soc.close()
                break

        soc.close()         # We've broken out of loop, so close socket.


    def __process_data(self, data):
        """ Process incoming data (from TestingServer) according to T->Q Protocol """
        params = data.strip().replace('\t', '').replace(_Set.EOM, '').split(_Set.SEP)

        # This actually needs to be entirely rewritten (but out of time) 
        # remove assumption that all data can be retreived with a single read.

        if len(params) > 1:

            # INIT SESS
            if params[0] == 'IS':
                #  "IS|session#|Questions|user|password" -> "OK/ERR"
                if len(params) == 5:
                    id = params[1]
                    q_num = params[2]
                    user = params[3]
                    pwd = params[4]
                    if self.__auth.authenticate(user, pwd):
                        session =  _Session(self.__qhandler, id, int(q_num))
                        self.__session_list.append(session)
                        reply = 'OK\n'
                    else:
                        reply = 'FAIL\n'
                else:
                    reply = 'ERR\n'
            # GET_Q 
            elif params[0] == 'QG':
                # "GQ|session#|Q#" -> "question|a|b|c|d or question"
                if len(params) == 3:
                    id = params[1]
                    q_id = params[2]

                    if any(s for s in self.__session_list if s.id == id):
                        session = first(s for s in self.__session_list if s.id == id)
                        question = session._get_question(int(q_id))

                if question:
                    question = _Set.SEP.join(question)
                    reply = question + '\n'
                else:
                    reply = 'ERR\n'

            # MARK_Q
            elif params[0] == 'QM':
                 #"MQ|session#|Question#|Ans#" -> "true/false"
                if len(params) == 4:
                    id = params[1]
                    q_id = params[2]
                    attempt = params[3]

                    if any(s for s in self.__session_list if s.id == id):
                        session = first(s for s in self.__session_list if s.id == id)
                        answer = session._get_answer(int(q_id))

                    if answer and attempt==answer:
                        reply = 'true\n'
                    else:
                        reply = 'false\n'
                else:
                    reply = 'ERR\n'
            else:
                reply = 'cont'
        else:
            reply = 'cont'

        return reply

    def start(self):

        if self.tls:
            ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
            ssl_context.load_cert_chain(certfile=_Set.KEY_LOC, keyfile=_Set.KEY_LOC)

        """ Function called to begin QuestionServer operation """
        s_socket = self.__start_listen()
        print("Type CTRL+C to terminate server")
        while True:                            # main infinite loop

            soc, addr = s_socket.accept()           # Wait to accept a connection - blocking call      
            print('Connected with '+addr[0]+':'+str(addr[1]))
            # Wrap SSL
            if self.tls:
                ssl_soc = ssl_context.wrap_socket(soc, server_side=True)
                thread.start_new_thread(self.__clientthread ,(ssl_soc,))

            else:
                thread.start_new_thread(self.__clientthread ,(soc,))

        s_socket.close()        # If we've broken out of the main loop, close socket.


def first(iterable, default=None):
  for item in iterable:
    return item
  return default

if __name__ == '__main__':

    host = _Set.HOST
    qport = _Set.QPORT
    tls = True

    if len(sys.argv) > 1:
        for arg in sys.argv:
            pairs = arg.split('=')
            if len(pairs) == 2:
                # tls=true/false
                if pairs[0] == 'tls':
                    if pairs[1] == 'true':
                        tls = True
                    elif pairs[1] == 'false':
                        tls = False
                # ques=QPORT
                elif pairs[0] == 'qport':
                    qport = pairs[1]

    qserver = _QuestionServer(host=host, qport=qport, tls=tls)
    qserver.start()
    exit
